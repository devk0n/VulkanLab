
// -------- ./source/vulkan/VulkanDevice.cpp --------

#include "VulkanDevice.h"

#include <set>

#include "Logger.h"

#include <vector>
#include <stdexcept>

VulkanDevice::VulkanDevice(VkInstance instance, GLFWwindow* window)
    : m_instance(instance)
{
    createSurface(window);
    pickPhysicalDevice();
    createLogicalDevice();

}

VulkanDevice::~VulkanDevice() {
    if (m_surface != VK_NULL_HANDLE) {
        vkDestroySurfaceKHR(m_instance, m_surface, nullptr);
        INFO("Surface destroyed.");
    }

    if (m_device != VK_NULL_HANDLE) {
        vkDestroyDevice(m_device, nullptr);
        INFO("Logical device destroyed.");
    }

}

void VulkanDevice::createSurface(GLFWwindow* window) {
    if (glfwCreateWindowSurface(m_instance, window, nullptr, &m_surface) != VK_SUCCESS) {
        throw std::runtime_error("Failed to create window surface.");
    }
    INFO("Surface created.");
}

void VulkanDevice::pickPhysicalDevice() {
    uint32_t count = 0;
    vkEnumeratePhysicalDevices(m_instance, &count, nullptr);
    if (count == 0) throw std::runtime_error("No Vulkan-supported GPUs found.");

    std::vector<VkPhysicalDevice> devices(count);
    vkEnumeratePhysicalDevices(m_instance, &count, devices.data());

    for (const auto& device : devices) {
        const QueueFamilyIndices indices = findQueueFamilies(device);
        if (indices.isComplete()) {
            m_physicalDevice = device;
            m_queueIndices = indices;
            INFO("Physical device selected.");
            return;
        }
    }

    throw std::runtime_error("No suitable GPU found.");
}

QueueFamilyIndices VulkanDevice::findQueueFamilies(VkPhysicalDevice device) const {
    QueueFamilyIndices indices;

    uint32_t count = 0;
    vkGetPhysicalDeviceQueueFamilyProperties(device, &count, nullptr);
    std::vector<VkQueueFamilyProperties> families(count);
    vkGetPhysicalDeviceQueueFamilyProperties(device, &count, families.data());

    for (uint32_t i = 0; i < count; ++i) {
        const auto& props = families[i];

        if (props.queueFlags & VK_QUEUE_GRAPHICS_BIT) {
            indices.graphics = i;
        }

        VkBool32 presentSupport = false;
        vkGetPhysicalDeviceSurfaceSupportKHR(device, i, m_surface, &presentSupport);
        if (presentSupport) {
            indices.present = i;
        }

        if (indices.isComplete()) break;
    }

    return indices;
}

void VulkanDevice::createLogicalDevice() {
    std::vector<VkDeviceQueueCreateInfo> queueCreateInfos;
    std::set uniqueQueueFamilies = {
        m_queueIndices.graphics.value(),
        m_queueIndices.present.value()
    };

    float queuePriority = 1.0f;
    for (const uint32_t family : uniqueQueueFamilies) {
        VkDeviceQueueCreateInfo queueInfo {
            .sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
            .queueFamilyIndex = family,
            .queueCount = 1,
            .pQueuePriorities = &queuePriority
        };
        queueCreateInfos.push_back(queueInfo);
    }

    VkPhysicalDeviceFeatures deviceFeatures{}; // Fill later when needed

    VkDeviceCreateInfo createInfo {
        .sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
        .queueCreateInfoCount = static_cast<uint32_t>(queueCreateInfos.size()),
        .pQueueCreateInfos = queueCreateInfos.data(),
        .pEnabledFeatures = &deviceFeatures,
    };

    const auto result = vkCreateDevice(m_physicalDevice, &createInfo, nullptr, &m_device);
    if (result != VK_SUCCESS || m_device == VK_NULL_HANDLE) {
        throw std::runtime_error("Failed to create logical device.");
    }

    INFO("Logical device created.");

    vkGetDeviceQueue(m_device, m_queueIndices.graphics.value(), 0, &m_graphicsQueue);
    vkGetDeviceQueue(m_device, m_queueIndices.present.value(), 0, &m_presentQueue);
}


// -------- ./source/vulkan/VulkanInstance.cpp --------

#include "VulkanInstance.h"

#include <cstring>
#include <expected>
#include <stdexcept>
#include <iostream>
#include <bits/ranges_algo.h>
#include <GLFW/glfw3.h>
#include "Logger.h"

namespace {
consteval auto validationLayers() {
    return std::to_array({
        "VK_LAYER_KHRONOS_validation"
    });
}
}

VulkanInstance::VulkanInstance(bool enableValidation)
    : m_enableValidation(enableValidation)
{
    if (m_enableValidation && !checkValidationLayerSupport()) {
        throw std::runtime_error("Validation layers requested but not available.");
    }

    const VkApplicationInfo appInfo {
        .sType = VK_STRUCTURE_TYPE_APPLICATION_INFO,
        .pApplicationName = "Fracture Framework",
        .applicationVersion = VK_MAKE_VERSION(1, 0, 0),
        .pEngineName = "Fracture",
        .engineVersion = VK_MAKE_VERSION(1, 0, 0),
        .apiVersion = VK_API_VERSION_1_3,
    };

    const auto extensions = getRequiredExtensions();

    VkInstanceCreateInfo createInfo {
        .sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
        .pApplicationInfo = &appInfo,
        .enabledExtensionCount = static_cast<uint32_t>(extensions.size()),
        .ppEnabledExtensionNames = extensions.data(),
        .enabledLayerCount = m_enableValidation ? static_cast<uint32_t>(validationLayers().size()) : 0,
        .ppEnabledLayerNames = m_enableValidation ? validationLayers().data() : nullptr,
    };

    if (const auto result = vkCreateInstance(&createInfo, nullptr, &m_instance);
        result != VK_SUCCESS || m_instance == VK_NULL_HANDLE) {
        throw std::runtime_error(std::format("Failed to create Vulkan instance. VkResult: {}", static_cast<int>(result)));
        }

    INFO("Vulkan instance created successfully.");
}

VulkanInstance::~VulkanInstance() {
    if (m_instance != VK_NULL_HANDLE) {
        vkDestroyInstance(m_instance, nullptr);
        INFO("Vulkan instance destroyed.");
    }
}

std::vector<const char*> VulkanInstance::getRequiredExtensions() const {
    uint32_t count = 0;
    const char** glfwExtensions = glfwGetRequiredInstanceExtensions(&count);
    std::vector extensions(glfwExtensions, glfwExtensions + count);

    if (m_enableValidation) {
        extensions.push_back("VK_EXT_debug_utils");
    }

    return extensions;
}

bool VulkanInstance::checkValidationLayerSupport() const {
    uint32_t layerCount = 0;
    vkEnumerateInstanceLayerProperties(&layerCount, nullptr);

    std::vector<VkLayerProperties> available(layerCount);
    vkEnumerateInstanceLayerProperties(&layerCount, available.data());

    for (const auto& requested : validationLayers()) {
        const bool found = std::ranges::any_of(available, [&](const auto& layer) {
            return std::strcmp(layer.layerName, requested) == 0;
        });

        if (!found) {
            WARN("Missing validation layer: {}", requested);
            return false;
        }
    }
    return true;
}


// -------- ./source/vulkan/VulkanDebugMessenger.cpp --------

#include "VulkanDebugMessenger.h"
#include "Logger.h"

#include <stdexcept>
#include <format>

VulkanDebugMessenger::VulkanDebugMessenger(VkInstance instance)
    : m_instance(instance)
{
    VkDebugUtilsMessengerCreateInfoEXT createInfo {
        .sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT,
        .messageSeverity =
            VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT |
            VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT |
            VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT,
        .messageType =
            VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT |
            VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT |
            VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT,
        .pfnUserCallback = &VulkanDebugMessenger::debugCallback
    };

    const auto func = reinterpret_cast<PFN_vkCreateDebugUtilsMessengerEXT>(
        vkGetInstanceProcAddr(m_instance, "vkCreateDebugUtilsMessengerEXT"));

    if (!func || func(m_instance, &createInfo, nullptr, &m_messenger) != VK_SUCCESS) {
        throw std::runtime_error("Failed to set up Vulkan debug messenger.");
    }

    INFO("Vulkan debug messenger initialized.");
}

VulkanDebugMessenger::~VulkanDebugMessenger() {
    if (m_messenger) {
        const auto func = reinterpret_cast<PFN_vkDestroyDebugUtilsMessengerEXT>(
            vkGetInstanceProcAddr(m_instance, "vkDestroyDebugUtilsMessengerEXT"));
        func(m_instance, m_messenger, nullptr);
        INFO("Vulkan debug messenger destroyed.");
    }
}

VkBool32 VKAPI_CALL VulkanDebugMessenger::debugCallback(
    VkDebugUtilsMessageSeverityFlagBitsEXT severity,
    VkDebugUtilsMessageTypeFlagsEXT,
    const VkDebugUtilsMessengerCallbackDataEXT* callbackData,
    void*)
{
    const std::string_view message = callbackData->pMessage;

    if (severity & VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT) {
        ERROR("Vulkan: ", message);
    } else if (severity & VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT) {
        WARN("Vulkan: ", message);
    } else {
        DEBUG("Vulkan: ", message);
    }

    return VK_FALSE;
}

// -------- ./source/core/Application.cpp --------

#include "Application.h"
#include "VulkanInstance.h"
#include "VulkanDebugMessenger.h"
#include "VulkanDevice.h"
#include "Logger.h"


Application::Application() {
    initialize();
}

Application::~Application() {
    cleanup();
}

void Application::run() {
    mainLoop();
}

void Application::initialize() {
    if (!glfwInit()) {
        ERROR("GLFW initialization failed.");
        throw std::runtime_error("Failed to initialize GLFW.");
    }

    glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
    glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE);

    m_window = glfwCreateWindow(1280, 720, "Fracture", nullptr, nullptr);
    if (!m_window) {
        ERROR("Failed to create GLFW window.");
        throw std::runtime_error("Failed to create window.");
    }

    INFO("GLFW window created.");

    m_vulkanInstance = std::make_unique<VulkanInstance>(true);
    m_debugMessenger = std::make_unique<VulkanDebugMessenger>(m_vulkanInstance->get());
    m_device = std::make_unique<VulkanDevice>(m_vulkanInstance->get(), m_window);
}

void Application::mainLoop() {
    while (!glfwWindowShouldClose(m_window)) {
        glfwPollEvents();
        // Draw frame here later
    }
}

void Application::cleanup() {
    m_device.reset();
    m_debugMessenger.reset();
    m_vulkanInstance.reset();

    if (m_window) {
        glfwDestroyWindow(m_window);
        m_window = nullptr;
    }
    glfwTerminate();
}
// -------- ./source/main.cpp --------

#include "Application.h"

int main() {
    Application app;
    app.run();

    return 0;
}
// -------- ./include/vulkan/VulkanDevice.h --------

#ifndef VULKAN_DEVICE_H
#define VULKAN_DEVICE_H

#include <vulkan/vulkan.h>
#include <GLFW/glfw3.h>
#include <optional>

struct QueueFamilyIndices {
    std::optional<uint32_t> graphics;
    std::optional<uint32_t> present;

    [[nodiscard]] bool isComplete() const {
        return graphics.has_value() && present.has_value();
    }
};

class VulkanDevice {
public:
    VulkanDevice(VkInstance instance, GLFWwindow* window);
    ~VulkanDevice();

    VulkanDevice(const VulkanDevice&) = delete;
    VulkanDevice& operator=(const VulkanDevice&) = delete;

    [[nodiscard]] VkPhysicalDevice getPhysicalDevice() const { return m_physicalDevice; }
    [[nodiscard]] VkSurfaceKHR getSurface() const { return m_surface; }
    [[nodiscard]] const QueueFamilyIndices& getQueueIndices() const { return m_queueIndices; }

    [[nodiscard]] VkDevice getDevice() const { return m_device; }
    [[nodiscard]] VkQueue getGraphicsQueue() const { return m_graphicsQueue; }
    [[nodiscard]] VkQueue getPresentQueue() const { return m_presentQueue; }


private:
    VkInstance m_instance = VK_NULL_HANDLE;
    VkSurfaceKHR m_surface = VK_NULL_HANDLE;
    VkPhysicalDevice m_physicalDevice = VK_NULL_HANDLE;
    QueueFamilyIndices m_queueIndices;

    void createSurface(GLFWwindow* window);
    void pickPhysicalDevice();
    QueueFamilyIndices findQueueFamilies(VkPhysicalDevice device) const;

    VkDevice m_device = VK_NULL_HANDLE;
    VkQueue m_graphicsQueue = VK_NULL_HANDLE;
    VkQueue m_presentQueue = VK_NULL_HANDLE;

    void createLogicalDevice();
};

#endif // VULKAN_DEVICE_H

// -------- ./include/vulkan/VulkanDebugMessenger.h --------

#ifndef VULKAN_DEBUG_MESSENGER_H
#define VULKAN_DEBUG_MESSENGER_H

#include <vulkan/vulkan.h>

class VulkanDebugMessenger {
public:
    explicit VulkanDebugMessenger(VkInstance instance);
    ~VulkanDebugMessenger();

    VulkanDebugMessenger(const VulkanDebugMessenger&) = delete;
    VulkanDebugMessenger& operator=(const VulkanDebugMessenger&) = delete;

private:
    VkInstance m_instance = VK_NULL_HANDLE;
    VkDebugUtilsMessengerEXT m_messenger = VK_NULL_HANDLE;

    static VKAPI_ATTR VkBool32 VKAPI_CALL debugCallback(
        VkDebugUtilsMessageSeverityFlagBitsEXT severity,
        VkDebugUtilsMessageTypeFlagsEXT type,
        const VkDebugUtilsMessengerCallbackDataEXT* callbackData,
        void* userData);
};

#endif // VULKAN_DEBUG_MESSENGER_H

// -------- ./include/vulkan/VulkanInstance.h --------

#ifndef VULKAN_INSTANCE_H
#define VULKAN_INSTANCE_H

#include <vulkan/vulkan.h>
#include <vector>

class VulkanInstance {
public:
    explicit(true) VulkanInstance(bool enableValidation);
    ~VulkanInstance();

    VulkanInstance(const VulkanInstance&) = delete;
    VulkanInstance& operator=(const VulkanInstance&) = delete;
    VulkanInstance(VulkanInstance&&) = delete;
    VulkanInstance& operator=(VulkanInstance&&) = delete;

    [[nodiscard]] VkInstance get() const noexcept { return m_instance; }

private:
    VkInstance m_instance = VK_NULL_HANDLE;
    bool m_enableValidation = false;

    [[nodiscard]] std::vector<const char*> getRequiredExtensions() const;
    [[nodiscard]] bool checkValidationLayerSupport() const;
};

#endif // VULKAN_INSTANCE_H

// -------- ./include/core/Application.h --------

#ifndef APPLICATION_H
#define APPLICATION_H

#include <memory>
#include <GLFW/glfw3.h>

class VulkanInstance;
class VulkanDebugMessenger;
class VulkanDevice;

class Application {
public:
    Application();
    ~Application();

    void run();

private:
    void initialize();
    void mainLoop();
    void cleanup();

    GLFWwindow* m_window = nullptr;
    std::unique_ptr<VulkanInstance> m_vulkanInstance;
    std::unique_ptr<VulkanDebugMessenger> m_debugMessenger;
    std::unique_ptr<VulkanDevice> m_device;
};

#endif // APPLICATION_H

// -------- ./include/Logger.h --------

#ifndef LOGGER_H
#define LOGGER_H

#include <chrono>
#include <ctime>
#include <iostream>
#include <mutex>
#include <sstream>
#include <string>
#include <unistd.h>

#if defined(_WIN32)
#include <windows.h>
#endif

class Logger {
public:
    enum class Level { Debug, Info, Warning, Error };

    struct Config {
        bool showTimestamp;
        bool showLevel;
        bool showSourceLocation;
        bool enableColors;

        constexpr Config()
            : showTimestamp(true),
              showLevel(true),
              showSourceLocation(true),
              enableColors(true) {}

        explicit constexpr Config(
            const bool timestamp,
            const bool level,
            const bool source,
            const bool color)
            : showTimestamp(timestamp),
              showLevel(level),
              showSourceLocation(source),
              enableColors(color) {}
    };

    static void setConfig(const Config& cfg) {
        std::lock_guard lock(mtx);
        m_config = cfg;
    }

    template <typename... Args>
    static void debug(const std::string& file, int line, const std::string& func, Args&&... args) {
        log(Level::Debug, file, line, func, std::forward<Args>(args)...);
    }

    template <typename... Args>
    static void info(const std::string& file, int line, const std::string& func, Args&&... args) {
        log(Level::Info, file, line, func, std::forward<Args>(args)...);
    }

    template <typename... Args>
    static void warn(const std::string& file, int line, const std::string& func, Args&&... args) {
        log(Level::Warning, file, line, func, std::forward<Args>(args)...);
    }

    template <typename... Args>
    static void error(const std::string& file, int line, const std::string& func, Args&&... args) {
        log(Level::Error, file, line, func, std::forward<Args>(args)...);
    }

private:
    static inline std::mutex mtx;
    static inline Config m_config{};

    static const char* levelToStr(const Level level) {
        switch (level) {
            case Level::Debug:   return "DEBUG";
            case Level::Info:    return "INFO";
            case Level::Warning: return "WARNING";
            case Level::Error:   return "ERROR";
        }
        return "UNKNOWN";
    }

    static const char* levelToColor(const Level level) {
        if (!shouldUseColors()) return "";
        switch (level) {
            case Level::Debug:   return "\033[38;5;44m";   // Teal Cyan
            case Level::Info:    return "\033[38;5;75m";   // Sky Blue
            case Level::Warning: return "\033[38;5;214m";  // Amber
            case Level::Error:   return "\033[38;5;203m";  // Soft Red
        }
        return "\033[0m";
    }

    static std::string formatSourceLocation(const std::string& file, const int line, const std::string& func) {
        const size_t lastSlash = file.find_last_of("/\\");
        const std::string filename = (lastSlash == std::string::npos)
            ? file
            : file.substr(lastSlash + 1);

        return filename + ":" + std::to_string(line);
    }

    static std::tm localTime(std::time_t time) {
        std::tm tm{};
        #if defined(_WIN32)
            localtime_s(&tm, &time);
        #else
            localtime_r(&time, &tm);
        #endif
        return tm;
    }

    static std::string currentTimestamp() {
        using namespace std::chrono;
        const auto now = system_clock::now();
        const std::time_t time = system_clock::to_time_t(now);
        const std::tm tm = localTime(time);

        char buffer[16];
        std::strftime(buffer, sizeof(buffer), "%H:%M:%S", &tm);
        return {buffer};
    }

    static bool shouldUseColors() {
        #if defined(_WIN32)
            static bool isTerminal = []() {
                HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
                if (hOut == INVALID_HANDLE_VALUE) return false;
                DWORD mode = 0;
                return GetConsoleMode(hOut, &mode);
            }();
            return isTerminal && m_config.enableColors;
        #else
            return m_config.enableColors && isatty(fileno(stdout));
        #endif
    }

    template <typename... Args>
    static void log(const Level level, const std::string& file, const int line, const std::string& func, Args&&... args) {
        std::ostringstream oss;

        if (m_config.showTimestamp) {
            const std::string timestamp = "[" + currentTimestamp() + "] ";
            oss << timestamp;
        }

        const std::string colorStart = levelToColor(level);
        const std::string colorEnd = shouldUseColors() ? "\033[0m" : "";

        if (m_config.showSourceLocation) {
            oss << "[" << formatSourceLocation(file, line, func) << "] ";
        }

        if (m_config.showLevel) {
            oss << colorStart << "[" << levelToStr(level) << "]" << " ";
        }

        (oss << ... << std::forward<Args>(args));

        const std::string message = oss.str();

        std::lock_guard lock(mtx);
        std::cout << message << "\n" << colorEnd;
    }
};

// Macros to capture source location
#define DEBUG(...) Logger::debug(__FILE__, __LINE__, __func__, __VA_ARGS__)
#define INFO(...)  Logger::info(__FILE__, __LINE__, __func__, __VA_ARGS__)
#define WARN(...)  Logger::warn(__FILE__, __LINE__, __func__, __VA_ARGS__)
#define ERROR(...) Logger::error(__FILE__, __LINE__, __func__, __VA_ARGS__)

#endif // LOGGER_H